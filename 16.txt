#include <iostream>

class Animal {
protected:
    std::string name;
    int age;

public:
    Animal(std::string name, int age) : name(name), age(age) {}

    virtual void speak() = 0;
    virtual void eat() = 0;


    std::string getName() { return name; }
    int getAge() { return age; }
};


class Dog : public Animal {
public:
    Dog(std::string name, int age) : Animal(name, age) {}

    void speak() override {
        std::cout << "Гав!" << std::endl;
    }

    void eat() override {
        std::cout << "Собака ест..." << std::endl;
    }
};
class Cat : public Animal {
public:
    Cat(std::string name, int age) : Animal(name, age) {}

    void speak() override {
        std::cout << "Мяу!" << std::endl;
    }

    void eat() override {
        std::cout << "Кот ест..." << std::endl;
    }
};

int main() {
    setlocale(LC_ALL, "RU");


    Dog myDog = Dog("Rex", 3);
    myDog.speak();
    myDog.eat();

    Cat myCat = Cat("Fluffy", 1);
    myCat.speak();
    myCat.eat();

    return 0;
}
//Объектно - ориентированное программирование(ООП) — это парадигма программирования, которая основана на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.ООП поддерживает следующие принципы :
//
//1. Абстракция : представление сущностей с помощью объектов, которые скрывают детали реализации.
//
//2. Наследование : возможность определения новых классов на основе существующих классов, что позволяет повторно использовать код.
//
//3. Полиморфизм : способность объектов разных классов участвовать в одном и том же контексте и реагировать на одни и те же сообщения разными способами.
//
//4. Инкапсуляция : объединение данных и методов, работающих с этими данными, в единое целое, что позволяет контролировать доступ к данным.
//
//5. Открытость / закрытость : классы должны быть открыты для расширения, но закрыты для модификации.
//
//6. Сокрытие информации : данные и методы класса скрыты от внешнего мира, что позволяет уменьшить сложность программы и улучшить её структуру.
//
//7. Единственность ответственности(Single Responsibility Principle, SRP) : класс должен иметь только одну причину для изменения.
//
//8. Принцип подстановки Лисков(Liskov Substitution Principle, LSP) : объекты в программе должны быть взаимозаменяемыми в рамках их контракта.
//
//9. Принцип открытости / закрытости(Open / Closed Principle, OCP) : программные сущности(классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.
//
//10. Принцип единственной ответственности(Single Responsibility Principle, SRP) : класс должен иметь только одну причину для изменения.
//
//11. Принцип разделения интерфейса(Interface Segregation Principle, ISP) : клиенты не должны зависеть от множества интерфейсов, которые они не используют.
//
//12. Принцип инверсии зависимостей(Dependency Inversion Principle, DIP) : модули высокого уровня не должны зависеть от модулей низкого уровня.Оба типа модулей должны зависеть от абстракций.
//Конструкция switch - case в C++ используется для множественного ветвления в соответствии с различными значениями выражения.Она позволяет выбрать один из нескольких вариантов действий на основе значения выражения.
//
//Вот пример использования switch - case:
//
//#include <iostream>
//
//    int main() {
//        int number = 2; // Текущее значение, которое мы будем проверять
//
//        // Используем switch для проверки значения number
//        switch (number) {
//        case 1: // Если number равно 1
//            std::cout << "Number is 1." << std::endl;
//            break; // Выходим из switch
//        case 2: // Если number равно 2
//            std::cout << "Number is 2." << std::endl;
//            break; // Выходим из switch
//        case 3: // Если number равно 3
//            std::cout << "Number is 3." << std::endl;
//            break; // Выходим из switch
//        default: // Если number не соответствует ни одному из вышеперечисленных случаев
//            std::cout << "Number is not 1, 2 or 3." << std::endl;
//            break; // Выходим из switch
//        }
//
//        return 0;
//    }
//
//
//    В этом примере переменная number проверяется на соответствие различным значениям с помощью switch.Для каждого случая выполняются определенные действия.Ключевое слово break используется для выхода из блока switch после выполнения соответствующего действия.Если ни один из случаев не соответствует значению number, выполняется блок default.
//
//        Важно отметить, что без break или return после каждого case, выполнение кода продолжится с первого последующего case, что может привести к неожиданному поведению программы.
