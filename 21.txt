№21
#include <iostream>

int sumOfDigits(int num) {
    int sum = 0;
    while (num > 0) {
        sum += num % 10;
        num /= 10;
    }
    return sum;
}

int main() {
    setlocale(LC_ALL, "Ru");
    int count = 0;

    for (int i = 0; i <= 999999; ++i) {
        if (sumOfDigits(i) == 25) {
            ++count;
        }
    }

    std::cout << "Количество чисел, у которых сумма цифр равна 25: " << count << std::endl;

    return 0;
}







/*
Вар21
Указатели в C++ являются одним из основных строительных блоков языка. Они позволяют управлять памятью и работать с данными на низком уровне.

Указатель — это переменная, которая хранит адрес другой переменной, структуры, массива или функции. Указатели позволяют изменять значения переменных, на которые они указывают, и даже изменять сами эти значения.

Вот пример использования указателей в C++:

#include <iostream>

int main() {
    int a = 5; // Объявление переменной a
    int b = 10; // Объявление переменной b

    // Объявление указателя на переменную типа int
    int *  ptr = &a; // ptr теперь указывает на переменную a

    // Вывод значения переменной, на которую указывает ptr
    std::cout << "Value of a: " <<  * ptr << std::endl; //  * ptr - разыменование указателя

    // Изменение значения переменной, на которую указывает ptr
     * ptr = 15; // Изменение значения переменной a через указатель

    // Вывод измененного значения переменной a
    std::cout << "New value of a: " << a << std::endl;

    // Изменение значения переменной b через указатель ptr
    ptr = &b; // Теперь ptr указывает на переменную b
     * ptr = 20; // Изменение значения переменной b через указатель

    // Вывод измененного значения переменной b
    std::cout << "New value of b: " << b << std::endl;

    return 0;
}


В этом примере мы создаем две переменные a и b, затем создаем указатель ptr, который указывает на переменную a. Мы выводим значение переменной a через указатель, затем изменяем значение a через указатель и выводим новое значение. После этого мы изменяем, на что указывает указатель ptr, так что теперь он указывает на переменную b, и изменяем значение b через указатель, выводя новое значение.

Указатели позволяют выполнять сложные операции с памятью, такие как работа с массивами, структурами и классами, но также могут привести к ошибкам, если не используются правильно, так как они позволяют напрямую изменять значения в памяти, что может привести к перезаписи данных или ошибкам сегментации.
Полиморфизм в C++ — это способность объекта одного класса вызывать методы, определенные в другом классе. Это означает, что если у вас есть базовый класс с определенным методом, то производный класс может переопределить этот метод, чтобы он выполнял другую функцию.

Пример полиморфизма в C++:

class Animal {
public:
    virtual void speak() = 0; // Абстрактный метод, который должен быть переопределен
};

class Dog : public Animal {
public:
    void speak() override { // Переопределение метода speak
        std::cout << "Woof!" << std::endl;
    }
};

class Cat : public Animal {
public:
    void speak() override { // Переопределение метода speak
        std::cout << "Meow!" << std::endl;
    }
};

int main() {
    Animal *  animals[] = {new Dog(), new Cat()}; // Массив указателей на Animal

    for (auto animalPtr : animals) {
        animalPtr->speak(); // Вызов метода speak для каждого объекта
        delete animalPtr; // Освобождение памяти
    }

    return 0;
}


В этом примере Animal является базовым классом, а Dog и Cat — производными классами. Метод speak() объявлен как виртуальный в базовом классе, что позволяет производным классам переопределить его поведение. Когда вы вызываете метод speak() для объекта, который на самом деле является объектом Dog или Cat, компилятор знает, какой метод вызвать, исходя из типа объекта, а не типа указателя. Это и есть полиморфизм.

*/