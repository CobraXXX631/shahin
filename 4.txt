#include <iostream>
#include <math.h>
using namespace std;


int M_PI = 3.14159265358979323846;
class Shape {
public:
    virtual double area() = 0;
    virtual double perimeter() = 0;
};

class Rectangle : public Shape {
public:
    double width;
    double height;
    Rectangle(double width, double height) : width(width), height(height) {}
    double area() override { return width * height; }
    double perimeter() override { return 2 * (width + height); }
};

class Circle : public Shape {
public:
    double radius;
    Circle(double radius) : radius(radius) {}
    double area() override { return M_PI * radius * radius; }
    double perimeter() override { return 2 * M_PI * radius; }
};

int main() {
    setlocale(LC_ALL, "RU");
    Shape* shapes[] = { new Rectangle(2.0, 3.0), new Circle(4.0) };
    for (int i = 0; i < 2; i++) {
        cout << "Площадь: " << shapes[i]->area() << endl;
        cout << "Периметр: " << shapes[i]->perimeter() << endl;
        cout << endl;
    }
    return 0;
}

//В языке программирования C++ есть несколько методов сортировки данных.Вот некоторые из них :
//
//1. * *Простая сортировка(Selection Sort) * *: Этот метод ищет минимальный элемент в неупорядоченной части массива, меняет его местами с первым элементом в этой части, затем повторяет процесс для оставшейся части массива.
//
//void selectionSort(int arr[], int n) {
//    for (int i = 0; i < n - 1; i++) {
//        // Находим индекс минимального элемента в неотсортированной части
//        int min_index = i;
//        for (int j = i + 1; j < n; j++) {
//            if (arr[j] < arr[min_index]) {
//                min_index = j;
//            }
//        }
//        // Меняем местами найденный минимальный элемент с первым элементом неотсортированной части
//        int temp = arr[i];
//        arr[i] = arr[min_index];
//        arr[min_index] = temp;
//    }
//}
//
//
//2.     Сортировка вставками(Insertion Sort) : Этот метод сортировки сравнивает каждый элемент с предыдущими элементами и вставляет его на правильное место в уже отсортированном участке массива.
//
//void insertionSort(int arr[], int n) {
//    for (int i = 1; i < n; i++) {
//        int key = arr[i];
//        int j = i - 1;
//
//        // Перемещаем элементы arr[0..i-1], которые больше, чем key,
//        // на одну позицию вперед от их текущего положения
//        while (j >= 0 && arr[j] > key) {
//            arr[j + 1] = arr[j];
//            j = j - 1;
//        }
//        arr[j + 1] = key;
//    }
//}
//
//
//3.     Сортировка пузырьком(Bubble Sort) : Этот метод сравнивает соседние элементы друг с другом и меняет их местами, если они находятся в неправильном порядке.Процесс повторяется до тех пор, пока массив не будет отсортирован.
//
//void bubbleSort(int arr[], int n) {
//    for (int i = 0; i < n - 1; i++) {
//        // Проверяем каждую пару элементов и меняем их местами, если они перепутаны
//        for (int j = 0; j < n - i - 1; j++) {
//            if (arr[j] > arr[j + 1]) {
//                swap(&arr[j], &arr[j + 1]);
//            }
//        }
//    }
//}
//
//
//4.     Быстрая сортировка(Quick Sort) : Этот метод выбирает опорный элемент, затем разделяет массив на две части : одна содержит элементы меньше опорного, другая - больше.Быстрая сортировка является одним из самых быстрых алгоритмов сортировки, но она требует больше памяти и может быть менее устойчивой, чем некоторые другие методы.
//
//void quickSort(int arr[], int low, int high) {
//    if (low < high) {
//        int pi = partition(arr, low, high);
//        quickSort(arr, low, pi - 1);
//        quickSort(arr, pi + 1, high);
//    }
//}
//
//int partition(int arr[], int low, int high) {
//    int pivot = arr[high];
//    int i = (low - 1);
//    for (int j = low; j < high; j++) {
//        if (arr[j] <= pivot) {
//            i++;
//            swap(&arr[i], &arr[j]);
//        }
//    }
//    swap(&arr[i + 1], &arr[high]);
//    return (i + 1);
//}
//
//
//Это лишь несколько примеров методов сортировки в C++.Выбор метода зависит от конкретных требований к скорости, стабильности и другим характеристикам алгоритма сортировки.
//-----------------------------------------------------------------------------------------
//Создание многофайлового проекта в C++ начинается с создания основного файла(обычно с расширением.cpp), который включает все остальные файлы проекта.Затем создаются отдельные файлы для каждого класса или функции, которые будут использоваться в проекте.Каждый из этих файлов должен иметь расширение.h(для заголовочных файлов) или.cpp(для исполняемых файлов).
//
//Затем эти файлы должны быть включены в основной файл проекта.Заголовочные файлы включаются директивой #include, а исполняемые файлы могут быть включены напрямую или через заголовочные файлы.
//
//Пример структуры многофайлового проекта C++:
//
//1. Создайте основной файл main.cpp, который будет содержать функцию main().
//
//// main.cpp
//#include <iostream>
//
//// Включаем заголовочный файл другого класса или функции
//#include "MyClass.h"
//
//int main() {
//    // Создаем экземпляр класса Myclass
//    MyClass myObject;
//
//    // Вызываем метод класса
//    myObject.myMethod();
//
//    return 0;
//}
//
//
//2. Создайте отдельный файл для класса или функции, который будет использоваться в основном файле.Например, MyClass.h и MyClass.cpp:
//
//// MyClass.h
//#ifndef MYCLASS_H
//#define MYCLASS_H
//
//class MyClass {
//public:
//    void myMethod();
//};
//
//#endif // MYCLASS_H
//
//
//// MyClass.cpp
//#include "MyClass.h"
//
//void MyClass::myMethod() {
//    // Реализация метода
//    std::cout << "Method called!" << std::endl;
//}
//
//
//3. Убедитесь, что все файлы собраны вместе в одном месте, чтобы компилятор мог найти все необходимые файлы.
//
//4. Компилируйте и запускайте проект, используя командную строку или интегрированную среду разработки(IDE), такую как Visual Studio, CLion, Eclipse CDT и т.д.
//
//Важно помнить, что в C++ существует правило одного определения(One Definition Rule), согласно которому каждый класс, функция или переменная должны быть определены ровно один раз в программе.Это означает, что заголовочные файлы должны только объявлять классы и функции, а реализация должна находиться в соответствующих исполняемых файлах.
