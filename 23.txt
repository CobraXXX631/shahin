№23
#include <iostream>
#include <vector>
#include <algorithm> 
double calculateAverage(const std::vector<int>& array) {
    double sum = 0;
    for (int value : array) {
        sum += value;
    }
    return sum / array.size();
}

int findMinElement(const std::vector<int>& array) {
    return  *std::min_element(array.begin(), array.end());
}

void replaceMinElementsWithAverage(std::vector<int>& array) {
    int minElement = findMinElement(array);
    double average = calculateAverage(array);

    std::transform(std::begin(array), std::end(array), std::begin(array),
        [&](int x) { return x == minElement ? static_cast<int>(average) : x; });
}

int main() {
    std::vector<int> array = { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5 };
    replaceMinElementsWithAverage(array);

    for (int value : array) {
        std::cout << value << " ";
    }
    std::cout << std::endl;

    return 0;
}









/*
Вар23
Массивы в C++ создаются с помощью квадратных скобок. Вот пример создания и инициализации массива целых чисел:

int myArray[5] = {1, 2, 3, 4, 5};


В этом примере создается массив из пяти элементов типа int, и каждый элемент инициализируется значением из списка инициализации.

Основные операции над массивами включают доступ к элементам массива, изменение элементов, копирование массивов и т.д. Вот примеры некоторых операций:

// Доступ к элементу массива
int element = myArray[2]; // element теперь равно 3

// Изменение элемента массива
myArray[2] = 10; // Изменяем третий элемент массива на 10

// Копирование массива
int anotherArray[5];
for (int i = 0; i < 5; ++i) {
    anotherArray[i] = myArray[i]; // Копируем элементы из myArray в anotherArray
}


Также в C++ можно использовать динамические массивы, создавая их с помощью оператора new и освобождая память с помощью delete или delete[] для массивов.
Методы перебора в задачах поиска в C++ могут включать в себя различные алгоритмы и структуры данных, такие как:

1.  *  * Линейный поиск (Linear Search) *  * : Простой метод, который проверяет каждый элемент массива на соответствие искомому значению.

2.  *  * Бинарный поиск (Binary Search) *  * : Эффективный метод для поиска в отсортированных массивах. Он делит массив на две части и продолжает сужать область поиска до тех пор, пока не найдет искомый элемент или не убедится в его отсутствии.

3.  *  * Поиск с возвратом (Backtracking) *  * : Метод, который используется для решения задач поиска в глубину, где возможны множественные пути к решению. Он позволяет "отступить" и попробовать другой путь, если текущий не приводит к решению.

4.  *  * Алгоритм Дейкстры (Dijkstra's Algorithm) *  * : Алгоритм для нахождения кратчайшего пути в графе с неотрицательными весами ребер.

5.  *  * Алгоритм Беллмана-Форда (Bellman-Ford Algorithm) *  * : Алгоритм для нахождения кратчайшего пути в графе с неотрицательными весами ребер, который также может обрабатывать ребра с отрицательными весами, если нет циклов отрицательного веса.

6.  *  * Алгоритм А *  (A * ) *  * : Метод поиска, который использует оценку функции стоимости для определения следующего шага в поиске. Он сочетает в себе эффективность алгоритма поиска с возвратом с возможностью оценки расстояния до цели.

7.  *  * Алгоритм Хаффмана (Huffman's Algorithm) *  * : Алгоритм для построения оптимального префиксного кода на основе частоты символов.

8.  *  * Алгоритм Кнута-Морриса-Пратта (Knuth-Morris-Pratt Algorithm) *  * : Алгоритм для поиска подстроки в строке.

9.  *  * Алгоритм Рабина-Карпа (Rabin-Karp Algorithm) *  * : Алгоритм для поиска подстроки в строке, который использует хеш-функцию для ускорения процесса.

10.  *  * Алгоритм сортировки (Sorting Algorithms) *  * : Алгоритмы, которые упорядочивают элементы массива, такие как сортировка выбором, вставками, пузырьком и другие.

Это лишь некоторые из методов перебора, которые могут быть использованы в задачах поиска в C++. Выбор конкретного метода зависит от специфики задачи и требуемой эффективности.

*/